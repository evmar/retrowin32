//! Generates .s and .def files for builtin DLLs.

use crate::parse;
use std::fmt::Write;

fn generate_asm(dllexports: &parse::DllExports) -> anyhow::Result<String> {
    // Note: it is critical that the DLL's exported fns match up to the shims array
    // generated in the shims module.  This means we must first export all the fns
    // found in dllexports.fns, before exporting any other fns (like the .is_none entries
    // in the vtable).

    let mut f = String::new();
    writeln!(f, "# generated by win32/derive")?;
    writeln!(f, ".intel_syntax noprefix")?;
    for dllexport in &dllexports.fns {
        writeln!(f, ".globl _{}", dllexport.flat_name)?;
        writeln!(f, "_{}:", dllexport.flat_name)?;
        writeln!(f, "  call [__imp__retrowin32_syscall]")?;
        let stack = dllexport.stack_consumed();
        if stack > 0 {
            writeln!(f, "  ret {}", stack)?;
        } else {
            writeln!(f, "  ret")?;
        }
    }

    for vtable in &dllexports.vtables {
        for (name, imp) in &vtable.fns {
            if imp.is_none() {
                writeln!(f, ".globl _{}_{}", vtable.name, name)?;
                writeln!(f, "_{}_{}:", vtable.name, name)?;
                writeln!(f, "  .byte 0x0f,0x0b")?; // ud2
            }
        }
        writeln!(f, ".globl _{}", vtable.name)?;
        writeln!(f, "_{}:", vtable.name)?;
        for (name, imp) in &vtable.fns {
            let name = match imp {
                Some(imp) => imp.clone(),
                None => format!("{}_{}", vtable.name, name),
            };
            writeln!(f, "  .long _{}", name)?;
        }
    }

    for data in &dllexports.data {
        writeln!(f, ".globl _{}", data.name)?;
        writeln!(f, "_{}:", data.name)?;
        if let Some(raw_asm) = &data.raw_asm {
            writeln!(f, "  {}", raw_asm)?;
        } else {
            // Note: we could do `.comm foo, 4` here to place this in a rw .data section
            // distinct from the read-only data section the vtables are in,
            // but given retrowin32 doesn't enforce read-only data anyway we might as
            // well keep it all together.
            writeln!(f, "  .long 0")?;
        }
    }
    Ok(f)
}

fn generate_def(module_name: &str, dllexports: &parse::DllExports) -> anyhow::Result<String> {
    let mut f = String::new();
    writeln!(f, "; generated by win32/derive")?;
    writeln!(f, "LIBRARY {}", module_name)?;
    writeln!(f, "EXPORTS")?;
    for dllexport in &dllexports.fns {
        let ordinal = dllexport.meta.ordinal.unwrap();
        match &dllexport.meta.symbol {
            Some(symbol) => writeln!(f, "  {}={} @{}", symbol, dllexport.flat_name, ordinal)?,
            None => writeln!(f, "  {} @{}", dllexport.flat_name, ordinal)?,
        }
    }
    for vtable in &dllexports.vtables {
        writeln!(f, "  {} DATA", vtable.name)?;
        // Even when the vtable fns are no-op int3s, we still want to export them
        // so the machinery that gathers labels of addresses knows what they are.
        for (name, imp) in &vtable.fns {
            if imp.is_none() {
                writeln!(f, "  {}_{}", vtable.name, name)?;
            }
        }
    }
    for data in &dllexports.data {
        writeln!(f, "  {} DATA", data.name)?;
    }
    Ok(f)
}

pub fn generate_dll(
    module_name: &str,
    dllexports: &parse::DllExports,
    mut write_file: impl FnMut(String, Vec<u8>) -> anyhow::Result<()>,
) -> anyhow::Result<()> {
    write_file(
        format!("{}.s", module_name),
        generate_asm(dllexports)?.into_bytes(),
    )?;
    write_file(
        format!("{}.def", module_name),
        generate_def(module_name, dllexports)?.into_bytes(),
    )?;
    Ok(())
}
